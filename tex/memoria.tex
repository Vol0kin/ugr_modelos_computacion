\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}	% Con hidelinks no se muestran los recuadros rojos
\usepackage{tikz}
\usepackage{makecell}
\usepackage{float}
\usepackage{enumitem}
\usepackage[textwidth=390pt]{geometry}

%Códigos fuente
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ 
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=C,                     % the language of the code
  morekeywords={*,private},        % add more keywords to the set
  numbers=left,                    % where to put the line-numbers (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If 1, each line si numbered
  stringstyle=\color{magenta},     % string literal style
  tabsize=2,                    % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

%Opciones de encabezado y pie de página:
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{}
\rhead{}
\lfoot{Modelos de Computación}
\cfoot{}
\rfoot{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\setlength{\parskip}{10pt}
\setlength{\parindent}{0pt}

\newcommand{\enu}{\textit{Enunciado}}
\newcommand{\sol}{\textbf{Solución}}
\newcommand{\noindentsect}{\setlength{\parindent}{0pt}}
\newcommand{\defaultindent}{\setlength{\parindent}{15pt}}

\begin{document}
	\pagenumbering{gobble}
	
	% Pagina de titulo
	\begin{titlepage}

		\begin{minipage}{\textwidth}

			\centering
			\textsc{\Large Modelos de Computación\\[0.2cm]}
			\textsc{GRADO EN INGENIERÍA INFORMÁTICA}\\[1cm]

			\noindent\rule[-1ex]{\textwidth}{1pt}\\[3.5ex]
			{\Huge Memoria de prácticas\\}
			\noindent\rule[-1ex]{\textwidth}{2pt}\\[3.5ex]
			%{\large\bfseries Ejercicio 5}
		\end{minipage}

		\vspace{1.5cm}
		
		\begin{minipage}{\textwidth}
			\centering

			\textbf{Autor}\\ {Vladislav Nikolov Vasilev}\\[2.5ex]

			\vspace{1cm}
			\textsc{Escuela Técnica Superior de Ingenierías Informática y de Telecomunicación}\\
			\vspace{1cm}
			\textsc{Curso 2018-2019}
		\end{minipage}
	\end{titlepage}
	
	% Indice
	\pagenumbering{arabic}
	\tableofcontents
	\newpage
	
	\section{Prácticas}
	
	\subsection{Práctica 1}
	
		\subsubsection{Ejercicio 1}
		\enu. Calcula una gramática libre de contexto que genere el lenguaje  
		$L = \lbrace a^n b^m c^m d^{2n}$ 
		tal que 
		$ n, m \geq 0 \rbrace$. \par
		
		\sol \par
		
		
		Se define la gramática como una cuádrupla con la forma $G = (V, T, P, S)$, siendo \textit{V} el conjunto
		de variables, \textit{T} el conjunto de elementos terminales, \textit{P} las reglas de producción y
		\textit{S} el símbolo inicial. Se puede definir cada uno de los conjuntos de la siguiente forma: \par
		\[V = \lbrace S, X, Y \rbrace\]
		\[T = \lbrace a, b, c, d \rbrace\]
		\[P = \lbrace S \rightarrow aXdd \; | \; bYc \; | \; \varepsilon, 
			   \; X \rightarrow aXdd \; | \; bYc \; | \; add \; | \; \varepsilon,
			   \; Y \rightarrow bYc \; | \; bc \; | \; \varepsilon \rbrace
		\]
		\[S = \lbrace S \rbrace \]
		\par
		
		Ésta es una gramática de \textbf{tipo 2}, ya que a la izquierda aparce una variable sola, sin símbolos
		terminales, y a la derecha aparece la variable con símbolos terminales tanto por la derecha como por la
		izquierda, impidiendo por tanto que sea regular por la izquierda o por la derecha. \par
		
		Con ésta gramática, primero se escoge si se van a empezar a generar una \textit{a} con la secuencia
		\textit{dd} al final, o si directamente se comenzará a generar la secuencia \textit{b} seguida de
		\textit{c}. Si se escoge la primera opción, se ponen tantas \textit{a} al principio y \textit{dd} al
		final como sea necesario, y después se puede escoger si se sigue con las \textit{b} y \textit{c}, o
		si se termina sin poner ninguno de los símbolos anteriores. Si se decide comenzar a poner \textit{b}
		y \textit{c} desde el principio o después de poner todas las \textit{a} y \textit{dd} que se quieran,
		se ponen todas las \textit{b} y \textit{c} que se quieran, hasta que se decida terminar la secuencia.
		\par
		
		Gracias a las reglas de producción se pueden satisfacer todas las restricciones del lenguaje, ya que
		por cada  \textit{a} se genera \textit{dd}, y por cada \textit{b} se genera \textit{c}. Además, se puede
		aceptar la cadena vacía o que alguna de las partes no esté.
		
		\subsubsection{Ejercicio 2}
		\enu. Describir una gramática que genere los números decimales escritos con el formato
		[signo][cifra][punto][cifra]. Por ejemplo, +3.45433, -453.23344, ...\par

		\sol \par
		La solución más sencilla que se puede ofrecer a este problema consiste en utilizar una gramática
		libre de contexto, como se mostrará a continuación. No obstante, el problema también es resoluble
		mediante una gramática regular, aumentando sin embargo el número de producciones y de variables
		necesarias. \par
		
		Definimos la gramática como una cuádrupla con la forma $G = (V, T, P, S)$, siendo \textit{V} el conjunto
		de variables, \textit{T} el conjunto de elementos terminales, \textit{P} las reglas de producción y
		\textit{S} el símbolo inicial. Se puede definir cada uno de los conjuntos de la siguiente forma: \par
		
		\[V = \lbrace S, X \rbrace \]
		\[T = \lbrace 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ., +, -\rbrace \]
		\[P = \left\{\begin{array}{c}
    			S \rightarrow +X.X \; | \; -X.X \\
    			X \rightarrow 0X \; | \; 1X \; | \; 2X \; | \; 3X \; | \; 4X \; | \; 5X \; | \;
    			6X \; | \; 7X \; | \; 8X \; | \; 9X \; | \\ 
    			0 \; | \; 1 \; | \; 2 \; | \; 3 \; | \; 4 \; | \; 5 \; | \; 6 \; | \;
    			7 \; | \; 8 \; | \; 9
  			\end{array}\right\}
		\]
		\[S = \lbrace S \rbrace \]
		
		Primero se genera el signo y el punto, pudiendo escoger si el número es positivo o negativo. Después,
		en la parte entera y decimal se van generando números en el rango $[0, 9]$, pudiendo escoger cuál es
		el siguiente número o cuando terminar de insertar números.
				 
		
		\subsubsection{Ejercicio 3}
		\enu. Calcula una gramática libre de contexto que genere el lenguaje
		$L = \lbrace 0^i 1^j 2^k$
		tal que
		$i \neq j$ o $j \neq k \rbrace$. \par
		
		\sol \par
		
		Definimos la gramática como una cuádrupla con la forma $G = (V, T, P, S)$, siendo \textit{V} el conjunto
		de variables, \textit{T} el conjunto de elementos terminales, \textit{P} las reglas de producción y
		\textit{S} el símbolo inicial. Se puede definir cada uno de los conjuntos de la siguiente forma: \par
		
		\[V = \lbrace S, X, Y, Z, P, R, A, B, M, K, U, D, N, L, C, Q \rbrace \]
		\[T = \lbrace 0, 1, 2 \rbrace \]
		\[P = \left\{
		\begin{array}{c}
			S \rightarrow 0X1 \; | \; 0Y2 \; | \; 1Z2 \; | \; 0A1P2 \; | \; 0R1B2, \;
			X \rightarrow 0X \; | \; X1 \; | \; \varepsilon \\
			Y \rightarrow 0Y \; | \; Y2 \; | \; \varepsilon, \;
			Z \rightarrow 1Z \; | \; Z2 \; | \; \varepsilon, \;
			P \rightarrow P2 \; | \; \varepsilon, \;
			R \rightarrow 0R \; | \; \varepsilon, \\
			A \rightarrow 0M \; | \; N1, \;
			M \rightarrow OMU \; | \; \varepsilon, \;
			U \rightarrow 1 \; | \; \varepsilon, \;
			N \rightarrow CN1 \; | \; \varepsilon, \;
			C \rightarrow 0 \; | \; \varepsilon, \\
			B \rightarrow 1K \; | \; L2, \;
			K \rightarrow 1KD \; | \; \varepsilon, \;
			D \rightarrow 2 \; | \; \varepsilon, \;
			L \rightarrow QL2 \; | \; \varepsilon, \;
			Q \rightarrow 1 \; | \; \varepsilon
		\end{array}
		\right\}\]
		\[S = \lbrace S \rbrace \]
		
		Ya que hay muchas reglas y puede no llegar a quedar claro para qué es cada una, vamos a ir 
		comentándolas para que no queden dudas sobre el por qué de cada una de ellas. \par
		
		La primera de ellas, $S \rightarrow 0X1$, indica que solo se van a producir los símbolos
		0 y 1, dándose por tanto la condición $j \neq k$, ya que no hay ningún símbolo 2. $X$ puede ser
		sustituido por tantos 0 o 1 como se desee, lo cuál corresponde a la producción $X \rightarrow 0X \;
		| \; X1 \; | \; \varepsilon$. \par
		
		Después tenemos la producción $S \rightarrow 0Y2$, la cuál es parecida a la anterior, solo que
		esta vez se producen solo los símbolos 0 y 2, satisfaciendo por tanto las condiciones $i \neq j$
		y $j \neq k$ simultáneamente. La variable $Y$ puede ser sustituida por tantos 0 o 2 como se desee,
		lo cuál se corresponde con la producción $Y \rightarrow 0Y \; | \; Y2 \; | \; \varepsilon$. \par
		
		La regla $S \rightarrow 1Z2$ permite producir los símbolos 1 y 2. En este caso, esta regla permite
		satisfacer la restricción $i \neq j$, ya que no se produce ningún símbolo 0. La variable $Z$ puede
		ser sustituida por tantos 1 y 2 como se desee. Ésto se corresponde con la producción $Z \rightarrow 1Z
		\; | \; Z2 \; | \; \varepsilon$. \par
		
		La regla $S \rightarrow 0A1P2$ permite producir los símbolos 0, 1 y 2, cumpliendo sin embargo la
		restricción $i \neq j$, introduciendo la desigualdad por tanto en la parte de los 0 y los 1, es decir,
		obligando que el número de 0 y de 1 sea diferente y permitiendo producir tantos 2 como se desee. La
		variable A se puede sustituir con la regla $A \rightarrow 0M \; | \; N1$, escogiendo si se quieren más 0
		que 1 (se escogería $OM$) o más 1 que 0 (se escogería en este caso $N1$). Al haber escogido estas reglas,
		se asegura que como mínimo hay un símbolo más de ese tipo. La variable $M$ puede ser sustituída por $M
		\rightarrow OMU \; | \; \varepsilon$, permitiendo poner tantos 0 como se deseen y poniendo por cada uno
		una variable $U$, la cuál puede ser sustituida luego por $U \rightarrow 1 \; | \; \varepsilon$, poniendo
		o no tantos 1 como 	$U$ haya. Hay que tener en cuenta que el número de 1 será siempre menor que
		el número de 0, ya que al principio, con $A \rightarrow 0M$ se puso un 0 extra, y como la regla $M
		\rightarrow OMU$ produce una variable que pueda ser sustituida por 1 por cada 0 nuevo que se coloca, se
		asegura que se cumplirá la	desigualdad $i \neq j$ como se mencionó anteriormente, siendo en este caso $i
		> j$ ya que $num(1) \leq num(0) - 1$. Algo similar ocurre con la regla $A \rightarrow N1$, ya que permite
		producir más 1 que 0 de la misma forma que antes. Primero se introduce un 1 extra y después se sustituye
		la variable $N$ por $N \rightarrow CN1 \; | \; \varepsilon$, permitiendo poner tantos 1 como se deseen y
		permitiendo poner un 0 por cada nuevo 1 que se añade (lo cuál se corresponde a la regla $C \rightarrow
		0 \; | \; \varepsilon$). Aquí ocurre lo mismo que en el caso anterior, ya que cumplirá la restricción $i
		\neq j$ verificando que $i < j$, debido a que $num(0) \leq num(1) - 1$. \par
		
		Finalmente tenemos la regla $S \rightarrow 0R1B2$, la cuál es similar a la anterior mencionada debido
		a que permite producir los símbolos 0, 1 y 2, satisfaciendo sin embargo la desigualdad $j \neq k$, lo
		cuál significa que se producen tantos 0 como se deseen, pero el número de 1 y de 2 tiene que ser
		distinto. La variable $R$ puede ser sustituída por $R \rightarrow 0R \; | \; \varepsilon$, es decir,
		por tantos 0 como se desee. La variable $B$ puede ser sustituída por $B \rightarrow 1K \; | \; L2$,
		permitiendo en el primer caso que haya más 1 que 2, y en el segundo caso que haya más 2 que 1.
		La variable $K$ puede ser sustituida por $K \rightarrow 1KD \; | \; \varepsilon$, poniendo un símbolo
		1, después otra variable $K$ y finalmente una variable $D$, la cuál puede ser sustituida mediante la
		regla $D \rightarrow 2 \; | \; \varepsilon$, poniendo como mucho tantos 2 como variables $D$ haya. Con
		esto se cumple la desigualdad $j \neq k$ ya que se ha puesto un 1 extra al principio, de forma que
		$j > k$ y $num(2) \leq num(1) - 1$. En el caso de querer más 2 que 1, se escogería $B \rightarrow L2$,
		sustituyendo luego la variable $L$ por $L \rightarrow QL2 \; | \; \varepsilon$, poniendo una variable
		$Q$, una variable $L$ y un 2. La variable $Q$ sería sustituida luego mediante la regla $Q \rightarrow 1
		\; | \; \varepsilon$, permitiendo poner un o ningún 1 por cada variable $Q$. En este caso se cumpliría
		que $j \neq k$ ya que $j < k$ porque se cumple que $num(1) \leq num(2) - 1$.
		
		
		\subsubsection{Ejercicio 4}
		\enu. Una empresa de videojuegos ``\textit{The fantastic platform}" están planteando diseñar
		una gramática capaz de generar niveles de un juego de plataformas, cada uno de los niveles
		siguiendo las siguientes restricciones:
		
		% Lista sin separación entre los elementos
		\begin{itemize}[noitemsep]
			\item Hay 2 grupos de enemigos: grupos grandes (\textit{g}) y grupos pequeños (\textit{p}).
			\item Hay 2 tipos de monstruos: fuertes (\textit{f}) y débiles (\textit{d}).
			\item Los grupos grandes de enemigos tienen, al menos, 1 monstruo fuerte y 1 débil.
				Y los 2 primeros monstruos pueden ir en cualquier orden. A partir del tercer
				monstruo, irán primero los débiles y después los fuertes.
			\item Los grupos pequeños tienen como mucho 1 monstruo fuerte.
			\item Al final de cada nivel habrá una sala de recompensas (\textit{x}).
		\end{itemize}
	
		% Se hace una seccion con un tamaño de letra pequeño
		\footnotesize
	
		Por ejemplo, la cadena terminal “\textit{gfddddfffpdddfx}” representa que el nivel tiene
		(\textit{gfddddfff}) un grupo grande con un monstruo fuerte, 4 débiles y otros 3 fuertes; 
		después tiene (\textit{pddddf}) un grupo pequeño con 3 débiles y uno fuerte. \par
	
		% Se restaura el tamaño de la letra al especificado en documentclass
		\normalsize	
		Elaborar una gramática que genere estos niveles con sus restricciones. Cada palabra del 
		lenguaje es un solo nivel. ¿A qué tipo de gramática dentro de la jerarquía de Chomsky 
		pertenece la gramática diseñada? \par
	
		¿Sería posible diseñar una gramática de tipo 3 para dicho problema? \par
	
		\sol \par
		
		Definimos la gramática como una cuádrupla con la forma $G = (V, T, P, S)$, siendo \textit{V} el conjunto
		de variables, \textit{T} el conjunto de elementos terminales, \textit{P} las reglas de producción y
		\textit{S} el símbolo inicial. Se puede definir cada uno de los conjuntos de la siguiente forma: \par
		
		\[V = \lbrace S, G, X, Y, Z, V, R, P, B \rbrace \]
		\[T = \lbrace g, p, f, d, x \rbrace \]
		\[P = \left\{
		\begin{array}{c}
		S \rightarrow gGx \; | \; pPx, \;
		G \rightarrow ddX \; | \; dfY \; | \; fdY \; | \; ffZ, \;
		X \rightarrow dX \; | \; fR, \\
		Y \rightarrow X \; | \; V \; | \; R \; | \; gG \; | \; pP \; | \; \varepsilon, \;
		Z \rightarrow dX \; | \; dV, \;
		V \rightarrow dV \; | \; gG \; | \; pP \; | \; \varepsilon, \\
		R \rightarrow fR \; | \; gG \; | \; pP \; | \; \varepsilon, \;
		P \rightarrow dP \; | \; dB \; | \; fB, \;
		B \rightarrow dB \; | \; gG \; | \; pP \; | \; \varepsilon		
		\end{array}
		\right\}		
		\]
		\[S = \lbrace S \rbrace \]
		
		La gramática es de \textbf{tipo 2}, ya que a la izquierda aparecen solo variables y a la derecha aparecen
		variables con símbolos terminales tanto por la derecha como por la izquierda o sin símbolos terminales, 
		impidiendo por tanto que sea regular, tanto por la derecha o regular por la izquierda. \par
		
		Una vez dicho esto, se va a proceder a explicar cómo funcionan las reglas de producción. Con $S \rightarrow gGx
		\; | \; pPx$ se escoge con qué grupo empezar primero: si uno grande ($gGx$) o uno pequeño ($pPx$). \par
		
		Si se escoge empezar con un grupo grande, como da igual en qué orden están los dos primeros enemigos, se puede
		sustituir la variable $G$ mediante la regla $G \rightarrow ddX \; | \; dfY \; | \; fdY \; | \; ffZ$. Si con la
		regla anterior se han producido dos enemigos débiles, se sustituye la variable $X$ mediante la regla X 
		$\rightarrow dX \; | \; fR$, que permite poner primero todos los enemigos débiles que se quieran y poner uno
		fuerte al final. Después de poner el fuerte, la variable $R$ se puede sustituir mediante la regla $R \rightarrow
		fR \; | \; gG \; | \; pP \; | \; \varepsilon$, que permite poner tantos enemigos fuertes como se quieran, y
		después un grupo grande, uno pequeño o terminar de poner grupos de enemigos. Si por el contrario, al principio
		del grupo grande se escogen poner dos enemigos fuertes, entonces se tiene que poner como mínimo un enemigo
		débil. Esto se hace a través de la variable $Z$, que se sustituye mediante la regla $Z \rightarrow dX \; | \;
		dV$, que pone un enemigo débil y permite escoger si seguir con la variable $X$ para poner enemigos débiles o
		fuertes, o seguir con la variable $V$, que se sustituye mediante la regla $V \rightarrow dV \; | \; gG \; | \;
		pP \; | \; \varepsilon$ y permite poner tantos enemigos débiles como se quieran o poner un nuevo grupo grande,
		pequeño o terminar de poner grupos. Si por el contrario se escoge poner un enemigo fuerte y uno débil, como ya
		se cumple la restricción del grupo grande, se puede sustituir la variable $Y$ mediante la regla $Y \rightarrow X
		\; | \; V \; | \; R \; | \; gG \; | \; pP \; | \; \varepsilon$, que permite poner enemigos fuertes y débiles,
		solo fuertes, solo débiles, poner un grupo grande, uno pequeño o terminar de insertar grupos.
		
		Si en cambio se escoge empezar con un grupo pequeño, la variable $P$ puede ser sustituida mediante la regla
		$P \rightarrow dP \; | \; dB \; | \; fB$, que permite poner tantos enemigos débiles como se quieran y se puede
		escoger si se quiere un enemigo fuerte, o si por el contrario solo se van a producir débiles. En todo caso, si
		se produce un enemigo fuerte o si no se decide producir se escoge el camino de la variable $B$, la cuál puede
		ser sustituida con la regla $B \rightarrow dB \; | \; gG \; | \; pP \; | \; \varepsilon$, permitiendo de nuevo
		poner cuantos enemigos débiles se desee, y después poner un grupo grande, uno pequeño o terminar de insertar
		grupos de enemigos. \par
		
		Como se puede comprobar, estas reglas permiten crear niveles de forma flexible, ya que se pueden combinar los
		grupos grandes y los pequeños en el orden que se quiera. Además, también permite generar los enemigos de una
		forma versátil, permitiendo muchas combinaciones posibles. \par
		
		Respecto a la segunda pregunta, es posible diseñar una gramática de tipo 3 para este problema. Esto se debe
		al hecho de que, aunque la gramática obtenida inicialmente sea de tipo de 2, no se garantiza que el lenguaje
		sea de tipo 2, si no que también puede ser de tipo 3. Para ello,definimos la gramática como una cuádrupla 
		$G = (V, T, P, S)$, donde $V$ son las variables, $T$ los símbolos terminales, $P$ las reglas de producción
		y $S$ el símbolo inicial. Cada uno de los conjuntos tendría la siguiente forma: \par
		
		\[V = \lbrace S, G, X, Y, Z, V, R, P, B \rbrace \]
		\[T = \lbrace g, p, f, d, x \rbrace \]
		\[P = \left\{
		\begin{array}{c}
		S \rightarrow gG \; | \; pP, \;
		G \rightarrow ddX \; | \; dfY \; | \; fdY \; | \; ffZ, \;
		X \rightarrow dX \; | \; fR, \\
		Y \rightarrow dX \; | \; dV \; | \; fR \; | \; gG \; | \; pP \; | \; x, \;
		Z \rightarrow dX \; | \; dV, \;
		V \rightarrow dV \; | \; gG \; | \; pP \; | \; x, \\
		R \rightarrow fR \; | \; gG \; | \; pP \; | \; x, \;
		P \rightarrow dP \; | \; dB \; | \; fB, \;
		B \rightarrow dB \; | \; gG \; | \; pP \; | \; x	
		\end{array}
		\right\}		
		\]
		\[S = \lbrace S \rbrace \]
		
		Como se puede comprobar fácilmente, esta gramática es de \textbf{tipo 3}, ya que a la izquierda aparece
		la variable sola y a la derecha aparece, o bien un símbolo terminal, o bien uno o más símbolos terminales
		acompañados de una variable a la derecha. Por tanto, se trata de una gramática regular por la derecha. \par
		
		Se puede comprobar fácilmente que esta gramática produce las mismas palabras que la anterior. Las diferencias
		son que el símbolo de recompensa de nivel $x$ se genera cuando no se quieren generar más grupos de enemigos
		en vez de al principio como se hacía antes. Esto también implica que todos los $\varepsilon$ se han sustituido
		por el símbolo $x$. Adicionalmente, para que el lenguaje fuese regular por la derecha, a las producciones de
		$Y$ que anteriormente solo implicaban un cambio de variable se les ha añadido un símbolo terminal
		que además cumple las restricciones impuestas por el problema (una $d$ para las variables $X$ y $V$ y una $f$
		para la variable $R$).
		
	
	\newpage
	\subsection{Práctica 2}
		Esta práctica ha sido realizada con mi compañera Nazaret Román Guerrero. Aquí se incluye la descripción y
		solución del problema para ambos alumnos. \par
		
		\subsubsection{Descripción del problema}
		El problema que se ha decidido abordar consiste en la creación de un programa capaz de traducir el lenguaje
		natural en código ejecutable en Python. Ya que de por sí el problema sería demasiado grande y complejo, lo
		hemos restringido a crear un traductor que permite convertir expresiones simples relacionadas con el manejo de
		listas en lenguaje natural a Python. \par
		Las funcionalidades que hemos decidido implementar son:
		\begin{itemize}
			\item Creación de listas, tanto vacías como con elementos.
			\item Inserción de elementos en las listas.
			\item Borrado de elementos de una lista.
			\item Obtención de un elemento en una posición de una lista.
			\item Imprimir una lista.
			\item Recorrer una lista, usando el delimitador por defecto o escogiendo uno que se desee.
			\item Obtener la longitud de una lista.
			\item Ordenar una lista, permitiendo que se ordene al revés.
			\item Copiar una lista en otra.
			\item Concatenar dos listas en una nueva o una ya existente.
			\item Comparar listas, permitiendo poner como expresión sumas de \textit{n} listas, la longitud de una
			lista, 	obtener el elemento de una lista, ordenar listas o comparar directamente listas entre sí. Los
			operadores que soporta la traducción son igual (==), diferente (!=), menor $(<)$, mayor $(>)$,
			menor o igual $(\leq)$ y mayor o igual $(\geq)$.
			\item Mostrar el resultado de la comparación.
		\end{itemize}
		
		Los elementos que se pueden insertar en listas son números enteros y reales (los reales tienen una parte entera
		separada por el símbolo gráfico . de la parte decimal) y cadenas de caracteres (encerradas entre comillas
		simples, con espacios y sin restricciones de longitud).
		
		\subsubsection{Resolución del problema}
		Para resolver el problema hemos utilizado la herramienta \textit{Flex}. Hemos creado un programa escrito en C
		que permite procesar símbolos de entrada y obtener la traducción en Python correspondiente. \par
		
		Se procede a mostrar ahora el codigo:
		
		\begin{lstlisting}
		/* ------------------- Declaraciones ------------------------ */

%option noyywrap
%{
#include <stdio.h>

char * procesado;
char * elem;
int i = 0;
int j = 0;
int comparar = 0;
char * comparacion;
%}

letra					[a-zA-Z]
digito				[0-9]
espacio				[ ]
entero				\-?{digito}+
numero				{entero}(\.{digito}+)?
delimitador		"'"[^\t\n]+"'"
cadena				"'"({letra}|{digito}|{espacio})*"'"
variable			({letra}|{digito}|_)+
crear					"crear "{variable}(" "({numero}|{cadena}|{espacio})+)?
longitud			"longitud "{variable}
imprimir			"imprimir "{variable}
recorrer			"recorrer "{variable}(" "{delimitador})?
insertar			"insertar "{variable}" "({cadena}|{numero})
borrar				"borrar "{variable}" "({cadena}|{numero})
obtener				"obtener "{variable}" "{entero}
copiar				"copiar "{variable}" "{variable}
concatenar		"concatenar "{variable}" "{variable}" "{variable}
ordenar				"ordenar "{variable}" reves"?
suma					{variable}" mas "{variable}(" mas "{variable})*
operador			"igual"|"diferente"|"menor"|"menor igual"|"mayor"|"mayor igual"
expresion			{longitud}|{suma}|{obtener}|{variable}|{ordenar}
comparar			"comparar "{expresion}" "{operador}" "{expresion}

%%

{crear}		{procesado = yytext + 6;
					char * lista = malloc(strlen(procesado));
					elem = malloc(strlen(procesado) * 2);
					for (i=0; i<strlen(procesado) && procesado[i] != ' '; i++)
							lista[i] = procesado[i];
							if (i < strlen(procesado)) {
									procesado += i + 1;
									j = 0;
									int cambiar_espacio_coma = 0;
									for (i = 0; i < strlen(procesado); i++) {
											if (procesado[i] == ' ') {
												if (cambiar_espacio_coma != 0) {
													elem[j] = ',';
													j++;
													elem[j] = ' ';
													j++;
													cambiar_espacio_coma = 0;
												}
											} else {
												elem[j] = procesado[i];
												j++;
												cambiar_espacio_coma = 1;
											}
									}
							}
							printf("%s = [%s]", lista, elem);}
{longitud}		{procesado = yytext + 9;
							if (comparar > 0)
								comparar--;
							printf("len(%s)", procesado);}
{imprimir}		{procesado=yytext + 9; printf("print(%s)", procesado);}
{recorrer}															{procesado = yytext + 9;
																		char * lista = malloc(strlen(procesado));
																		char * delim;
																		int usar_delim = 0;
																		for (i = 0; i < strlen(procesado) && procesado[i] != ' '; i++)
																			lista[i] = procesado[i];
																		if (strlen(procesado) >= i + 1)
																			usar_delim = 1;
																		procesado += i + 1;
																		delim = procesado;
																		printf("for item in %s:\n    print(item", lista);
																		if (usar_delim)
																			printf(", end = %s", delim);
																		printf(")");
																	}
{insertar}															{procesado = yytext + 9;
																		char * lista = malloc(strlen(procesado));
																		for (i = 0; i < strlen(procesado) && procesado[i] != ' '; i++)
																			lista[i] = procesado[i];
																		procesado += i + 1;
																		elem = procesado;
																		printf("%s.append(%s)", lista, elem);}
{borrar}															{procesado = yytext + 7;
																		char *lista = malloc(strlen(procesado));
																		for(i = 0; i < strlen(procesado) && procesado[i] != ' '; i++)
																			lista[i] = procesado[i];
																		procesado += i + 1;
																		elem = procesado;
																		printf("%s.remove(%s)", lista, elem);}
{obtener}															{procesado = yytext; procesado += 8;
																		char *lista = malloc(strlen(procesado));
																		for(i = 0; i < strlen(procesado) && procesado[i] != ' '; i++)
																			lista[i] = procesado[i];
																		procesado += i + 1;
																		elem = procesado;
																		if(comparar > 0) {
																			printf("%s[%s]", lista, elem);
																			comparar--;
																		}
																		else
																			printf("print(%s[%s])", lista, elem);}
{copiar}															{procesado = yytext + 7;
																		char *orig = malloc(strlen(procesado));
																		char *dest = malloc(strlen(procesado));
																		for(i = 0; i < strlen(procesado) && procesado[i] != ' '; i++)
																			orig[i] = procesado[i];
																		procesado += i + 1;
																		dest = procesado;
																		printf("%s = %s", dest, orig);}
{concatenar}														{procesado = yytext + 11;
																		char *l1 = malloc(strlen(procesado));
																		char *l2 = malloc(strlen(procesado));
																		char *dest = malloc(strlen(procesado));
																		for(i = 0; i < strlen(procesado) && procesado[i] != ' '; i++)
																			l1[i] = procesado[i];
																		procesado += i + 1;
																		for(i = 0; i < strlen(procesado) && procesado[i] != ' '; i++)
																			l2[i] = procesado[i];
																		procesado += i + 1;
																		dest = procesado;
																		printf("%s = %s + %s", dest, l1, l2);}
{ordenar}															{procesado = yytext + 8;
																		char *lista = malloc(strlen(procesado));
																		if (comparar > 0)
																			comparar--;
																		for(i = 0; i < strlen(procesado) && procesado[i] != ' '; i++)
																			lista[i] = procesado[i];
																		if (strlen(procesado) >= i + 1)
																			printf("%s.sort(reverse=True)", lista);
																		else
																			printf("%s.sort()", lista);}
{suma}																{procesado = yytext;
																		char * suma = malloc(strlen(procesado));
																		int salta_palabra = 0;
																		j = 0;

																		if (comparar > 0)
																			comparar--;
																		for(i = 0; i < strlen(procesado); i++) {
																			if (procesado[i] == ' ') {
																				salta_palabra = !salta_palabra & 0x1;
																				if(salta_palabra) {
																					suma[j] = ' ';
																					j++;
																					suma[j] = '+';
																					j++;
																					suma[j] = ' ';
																					j++;
																				}
																			} else {
																				if (!salta_palabra) {
																					suma[j] = procesado[i];
																					j++;
																				}
																			}
																		}
																		printf("%s", suma);}
{comparar}															{comparar = 2; printf("comparacion = "); yyless(9);}
{operador}															{procesado = yytext;
																		i = 0;
																		if(procesado[i] == 'i')
																			printf(" == ");
																		else if(procesado[i] == 'd')
																			printf(" != ");
																		else if(procesado[i] == 'm') {
																			if(procesado[i+1] == 'e' && yyleng == 5)
																				printf(" < ");
																			else if(procesado[i+1] == 'e' && yyleng > 5)
																				printf(" <= ");
																			else if(procesado[i+1] == 'a' && yyleng == 5)
																				printf(" > ");
																			else
																				printf(" >= ");}}
{variable}															{if (comparar > 0)
																			comparar--;
																	printf("%s", yytext);}
"mostrar comparacion"												{printf("print(comparacion)");}
.																	{}

%%

int main(int argc, char *argv[]) {

	if (argc == 2) {
		yyin = fopen(argv[1], "rt");

		if (yyin == NULL) {
			printf("El fichero %s no se pudo abrir\n", argv[1]);
			exit(-1);
		}
	} else
		yyin = stdin;

	yylex();

	return 0;
}
		\end{lstlisting}
		
		Cabe mencionar que a la hora de crear una lista, si se deciden insertart cadenas de caracteres, por la forma
		en la que está hecho el código, éstas no pueden contener espacios, ya que si no serían sustituidas por espacios.
		Cuando se inserten de otra forma sí que pueden contenerlos.
		
		\subsubsection{Pruebas}
		Para probar el funcionamiento del programa, vamos a pasarle un fichero de texto que contiene expresiones en
		lenguaje natural que deberán ser convertidas a Python. Aquí se puede ver un ejemplo de la salida obtenida:
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=\textwidth]{../img/ejemplo.png}
		\end{figure}
		
		Para comprobar que funciona, vamos a redirigir la salida a un fichero con extensión .py y vamos a probar
		a ejecutarlo con Python. Se puede ver el resultado en la siguiente imagen:
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=\textwidth]{../img/ejemplo-python.png}
		\end{figure}
	\newpage
	\subsection{Práctica 3}
	
	\newpage
	\subsection{Práctica 4}
	
	\newpage
	\section{Ejercicios voluntarios}
\end{document}